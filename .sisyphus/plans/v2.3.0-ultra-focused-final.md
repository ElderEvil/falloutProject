# v2.3.0 Ultra-Focused Quick Wins - FINAL Plan

**Status:** Ready for Implementation
**Created:** 2026-01-23
**Branch:** `feat/v2.3.0`
**Scope:** DB Init + Unique Room Tests ONLY
**Estimated Effort:** 3-4 hours
**Target Coverage:** 44.5% â†’ 55-60%

---

## Scope: Just 2 Tasks

### âœ… REMOVED FROM SCOPE
- âŒ Middleware tests (deferred)
- âŒ Datetime deprecation fix (deferred)
- âŒ Incident service tests (deferred)
- âŒ Game loop tests (deferred)

### âœ… IN SCOPE
1. **Database Initialization Tests** - 10 tests, 2-3 hours
2. **Unique Room Verification Tests** - 8 tests, 1-2 hours

**Total:** 18 new tests, 3-4 hours work

---

## Task 1: Database Initialization Tests ðŸ’¾

**Priority:** HIGH | **Effort:** 2-3 hours | **Coverage:** 0% â†’ 75%

### What We're Testing
The database seeding logic in `app/db/init_db.py`:
- Creates 2 users (superuser + test user)
- Creates vault for test user
- Seeds 3 rooms with 2 dwellers each
- Equips each dweller with outfit + weapon

### Test File
**Create:** `app/tests/test_db/test_init_db.py`

### Test Cases (10 tests)

```python
import pytest
from sqlmodel import select
from sqlmodel.ext.asyncio.session import AsyncSession

from app import crud
from app.core.config import settings
from app.db.init_db import init_db
from app.models.user import User
from app.models.vault import Vault
from app.models.room import Room
from app.models.dweller import Dweller
from app.models.outfit import Outfit
from app.models.weapon import Weapon


class TestInitDB:
    """Test database initialization seeding."""

    # User Creation Tests
    @pytest.mark.asyncio
    async def test_creates_superuser(self, async_session: AsyncSession):
        """Verify superuser is created with correct attributes."""
        await init_db(async_session)

        user = await crud.user.get_by_email(
            email=settings.FIRST_SUPERUSER_EMAIL,
            db_session=async_session
        )

        assert user is not None
        assert user.is_superuser is True
        assert user.username == settings.FIRST_SUPERUSER_USERNAME

    @pytest.mark.asyncio
    async def test_creates_test_user(self, async_session: AsyncSession):
        """Verify test user is created."""
        await init_db(async_session)

        user = await crud.user.get_by_email(
            email=settings.EMAIL_TEST_USER,
            db_session=async_session
        )

        assert user is not None
        assert user.is_superuser is False
        assert user.username == "TestUser"

    @pytest.mark.asyncio
    async def test_skips_existing_users(self, async_session: AsyncSession):
        """Verify init_db is idempotent - doesn't duplicate users."""
        # Run twice
        await init_db(async_session)
        await init_db(async_session)

        # Should only have 2 users total
        result = await async_session.execute(select(User))
        users = result.scalars().all()
        assert len(users) == 2

    # Vault Seeding Tests
    @pytest.mark.asyncio
    async def test_creates_vault_for_test_user_only(self, async_session: AsyncSession):
        """Verify vault created for test user, not superuser."""
        await init_db(async_session)

        test_user = await crud.user.get_by_email(
            email=settings.EMAIL_TEST_USER,
            db_session=async_session
        )
        superuser = await crud.user.get_by_email(
            email=settings.FIRST_SUPERUSER_EMAIL,
            db_session=async_session
        )

        # Test user should have vault
        test_vaults = await async_session.execute(
            select(Vault).where(Vault.user_id == test_user.id)
        )
        assert len(test_vaults.scalars().all()) == 1

        # Superuser should NOT have vault
        super_vaults = await async_session.execute(
            select(Vault).where(Vault.user_id == superuser.id)
        )
        assert len(super_vaults.scalars().all()) == 0

    @pytest.mark.asyncio
    async def test_creates_three_rooms(self, async_session: AsyncSession):
        """Verify 3 rooms created for test vault."""
        await init_db(async_session)

        test_user = await crud.user.get_by_email(
            email=settings.EMAIL_TEST_USER,
            db_session=async_session
        )

        rooms = await async_session.execute(
            select(Room).join(Vault).where(Vault.user_id == test_user.id)
        )
        assert len(rooms.scalars().all()) == 3

    @pytest.mark.asyncio
    async def test_creates_six_dwellers(self, async_session: AsyncSession):
        """Verify 2 dwellers per room (6 total)."""
        await init_db(async_session)

        test_user = await crud.user.get_by_email(
            email=settings.EMAIL_TEST_USER,
            db_session=async_session
        )

        dwellers = await async_session.execute(
            select(Dweller).join(Vault).where(Vault.user_id == test_user.id)
        )
        assert len(dwellers.scalars().all()) == 6

    # Equipment Tests
    @pytest.mark.asyncio
    async def test_creates_outfits_for_all_dwellers(self, async_session: AsyncSession):
        """Verify each dweller has an outfit."""
        await init_db(async_session)

        test_user = await crud.user.get_by_email(
            email=settings.EMAIL_TEST_USER,
            db_session=async_session
        )

        outfits = await async_session.execute(
            select(Outfit)
            .join(Dweller)
            .join(Vault)
            .where(Vault.user_id == test_user.id)
        )
        assert len(outfits.scalars().all()) == 6

    @pytest.mark.asyncio
    async def test_creates_weapons_for_all_dwellers(self, async_session: AsyncSession):
        """Verify each dweller has a weapon."""
        await init_db(async_session)

        test_user = await crud.user.get_by_email(
            email=settings.EMAIL_TEST_USER,
            db_session=async_session
        )

        weapons = await async_session.execute(
            select(Weapon)
            .join(Dweller)
            .join(Vault)
            .where(Vault.user_id == test_user.id)
        )
        assert len(weapons.scalars().all()) == 6

    # Integration Tests
    @pytest.mark.asyncio
    async def test_complete_hierarchy(self, async_session: AsyncSession):
        """Verify complete entity hierarchy: user â†’ vault â†’ rooms â†’ dwellers â†’ equipment."""
        await init_db(async_session)

        test_user = await crud.user.get_by_email(
            email=settings.EMAIL_TEST_USER,
            db_session=async_session
        )

        # Get vault
        vault_result = await async_session.execute(
            select(Vault).where(Vault.user_id == test_user.id)
        )
        vault = vault_result.scalar_one()

        # Get rooms
        rooms_result = await async_session.execute(
            select(Room).where(Room.vault_id == vault.id)
        )
        rooms = rooms_result.scalars().all()
        assert len(rooms) == 3

        # For each room, verify dwellers + equipment
        for room in rooms:
            dwellers_result = await async_session.execute(
                select(Dweller).where(Dweller.room_id == room.id)
            )
            dwellers = dwellers_result.scalars().all()
            assert len(dwellers) == 2

            for dweller in dwellers:
                # Check outfit
                outfit_result = await async_session.execute(
                    select(Outfit).where(Outfit.dweller_id == dweller.id)
                )
                assert outfit_result.scalar_one_or_none() is not None

                # Check weapon
                weapon_result = await async_session.execute(
                    select(Weapon).where(Weapon.dweller_id == dweller.id)
                )
                assert weapon_result.scalar_one_or_none() is not None

    @pytest.mark.asyncio
    async def test_dwellers_assigned_to_rooms(self, async_session: AsyncSession):
        """Verify dwellers are properly assigned to their rooms."""
        await init_db(async_session)

        test_user = await crud.user.get_by_email(
            email=settings.EMAIL_TEST_USER,
            db_session=async_session
        )

        rooms_result = await async_session.execute(
            select(Room).join(Vault).where(Vault.user_id == test_user.id)
        )
        rooms = rooms_result.scalars().all()

        for room in rooms:
            dwellers_result = await async_session.execute(
                select(Dweller).where(Dweller.room_id == room.id)
            )
            dwellers = dwellers_result.scalars().all()

            # Each room should have exactly 2 dwellers
            assert len(dwellers) == 2

            # Each dweller should reference this room
            for dweller in dwellers:
                assert dweller.room_id == room.id
                assert dweller.vault_id == room.vault_id
```

### Setup Required
1. Create directory: `mkdir -p backend/app/tests/test_db`
2. Create `__init__.py`: `touch backend/app/tests/test_db/__init__.py`
3. Create test file: `backend/app/tests/test_db/test_init_db.py`

### Acceptance Criteria
- [ ] Test directory exists: `app/tests/test_db/`
- [ ] 10 tests written and passing
- [ ] Coverage: `uv run pytest --cov=app.db.init_db --cov-report=term-missing`
- [ ] Target: â‰¥75% coverage for init_db.py

---

## Task 2: Unique Room Verification Tests ðŸ 

**Priority:** MEDIUM | **Effort:** 1-2 hours | **Coverage:** Improve from ~70% â†’ 95%

### What We're Testing
Unique room logic in:
- `app/models/room.py` - `is_unique` property
- `app/crud/room.py` - `check_is_unique_room()` and `build()` validation
- `app/api/v1/endpoints/room.py` - `/buildable/` filtering

### Test File
**Expand:** `app/tests/test_api/test_room.py`

### Test Cases (8 tests)

```python
import pytest
from uuid import uuid4
from httpx import AsyncClient

from app.models.room import Room
from app import crud
from app.schemas.vault import VaultCreate


class TestUniqueRoomLogic:
    """Test unique room filtering and validation."""

    # Property Tests
    @pytest.mark.asyncio
    async def test_is_unique_property_true_when_no_incremental_cost(self):
        """Room with no incremental_cost should be unique."""
        room = Room(
            name="Vault Door",
            vault_id=uuid4(),
            level=1,
            incremental_cost=None  # Unique rooms have None
        )
        assert room.is_unique is True

    @pytest.mark.asyncio
    async def test_is_unique_property_false_when_has_incremental_cost(self):
        """Room with incremental_cost should be non-unique."""
        room = Room(
            name="Power Generator",
            vault_id=uuid4(),
            level=1,
            incremental_cost={"caps": 500}  # Non-unique have cost
        )
        assert room.is_unique is False

    # Build Validation Tests
    @pytest.mark.asyncio
    async def test_cannot_build_duplicate_unique_room(
        self,
        async_client: AsyncClient,
        superuser_token_headers: dict,
        async_session,
    ):
        """Building duplicate unique room should fail."""
        # Create vault
        vault_data = {"name": "Test Vault", "max_dwellers": 200}
        vault = await crud.vault.create(
            async_session,
            obj_in=VaultCreate(**vault_data, user_id=uuid4())
        )
        await async_session.commit()

        # Build first Vault Door
        room_data = {
            "name": "Vault Door",
            "vault_id": str(vault.id),
            "level": 1
        }

        response1 = await async_client.post(
            "/api/v1/rooms/build/",
            json=room_data,
            headers=superuser_token_headers
        )
        assert response1.status_code == 201

        # Try to build second Vault Door (should fail)
        response2 = await async_client.post(
            "/api/v1/rooms/build/",
            json=room_data,
            headers=superuser_token_headers
        )
        assert response2.status_code == 400
        detail = response2.json()["detail"].lower()
        assert "unique" in detail or "already exists" in detail

    @pytest.mark.asyncio
    async def test_can_build_multiple_non_unique_rooms(
        self,
        async_client: AsyncClient,
        superuser_token_headers: dict,
        async_session,
    ):
        """Building multiple non-unique rooms should succeed."""
        vault_data = {"name": "Test Vault", "max_dwellers": 200}
        vault = await crud.vault.create(
            async_session,
            obj_in=VaultCreate(**vault_data, user_id=uuid4())
        )
        await async_session.commit()

        room_data = {
            "name": "Power Generator",
            "vault_id": str(vault.id),
            "level": 1
        }

        # Build first Power Generator
        response1 = await async_client.post(
            "/api/v1/rooms/build/",
            json=room_data,
            headers=superuser_token_headers
        )
        assert response1.status_code == 201

        # Build second Power Generator (should succeed)
        response2 = await async_client.post(
            "/api/v1/rooms/build/",
            json=room_data,
            headers=superuser_token_headers
        )
        assert response2.status_code == 201

    @pytest.mark.asyncio
    async def test_first_unique_room_builds_successfully(
        self,
        async_client: AsyncClient,
        superuser_token_headers: dict,
        async_session,
    ):
        """First unique room should build without issues."""
        vault_data = {"name": "Test Vault", "max_dwellers": 200}
        vault = await crud.vault.create(
            async_session,
            obj_in=VaultCreate(**vault_data, user_id=uuid4())
        )
        await async_session.commit()

        room_data = {
            "name": "Vault Door",
            "vault_id": str(vault.id),
            "level": 1
        }

        response = await async_client.post(
            "/api/v1/rooms/build/",
            json=room_data,
            headers=superuser_token_headers
        )

        assert response.status_code == 201
        data = response.json()
        assert data["name"] == "Vault Door"

    # Buildable Rooms Filtering Tests
    @pytest.mark.asyncio
    async def test_buildable_excludes_built_unique_rooms(
        self,
        async_client: AsyncClient,
        superuser_token_headers: dict,
        async_session,
    ):
        """Built unique rooms should not appear in buildable list."""
        vault_data = {"name": "Test Vault", "max_dwellers": 200}
        vault = await crud.vault.create(
            async_session,
            obj_in=VaultCreate(**vault_data, user_id=uuid4())
        )

        # Build Vault Door
        await crud.room.build(
            async_session,
            vault_id=vault.id,
            room_name="Vault Door",
            level=1
        )
        await async_session.commit()

        # Check buildable rooms
        response = await async_client.get(
            f"/api/v1/rooms/buildable/{vault.id}/",
            headers=superuser_token_headers
        )

        assert response.status_code == 200
        buildable = response.json()

        # Vault Door should NOT be in list
        vault_doors = [r for r in buildable if r["name"] == "Vault Door"]
        assert len(vault_doors) == 0

    @pytest.mark.asyncio
    async def test_buildable_includes_unbuilt_unique_rooms(
        self,
        async_client: AsyncClient,
        superuser_token_headers: dict,
        async_session,
    ):
        """Unbuilt unique rooms should appear in buildable list."""
        vault_data = {"name": "Test Vault", "max_dwellers": 200}
        vault = await crud.vault.create(
            async_session,
            obj_in=VaultCreate(**vault_data, user_id=uuid4())
        )
        await async_session.commit()

        response = await async_client.get(
            f"/api/v1/rooms/buildable/{vault.id}/",
            headers=superuser_token_headers
        )

        assert response.status_code == 200
        buildable = response.json()

        # Vault Door should be in list (not built yet)
        vault_doors = [r for r in buildable if r["name"] == "Vault Door"]
        assert len(vault_doors) > 0

    @pytest.mark.asyncio
    async def test_buildable_always_includes_non_unique_rooms(
        self,
        async_client: AsyncClient,
        superuser_token_headers: dict,
        async_session,
    ):
        """Non-unique rooms should always be buildable, even if built."""
        vault_data = {"name": "Test Vault", "max_dwellers": 200}
        vault = await crud.vault.create(
            async_session,
            obj_in=VaultCreate(**vault_data, user_id=uuid4())
        )

        # Build Power Generator
        await crud.room.build(
            async_session,
            vault_id=vault.id,
            room_name="Power Generator",
            level=1
        )
        await async_session.commit()

        response = await async_client.get(
            f"/api/v1/rooms/buildable/{vault.id}/",
            headers=superuser_token_headers
        )

        assert response.status_code == 200
        buildable = response.json()

        # Power Generator should still be buildable
        power_gens = [r for r in buildable if r["name"] == "Power Generator"]
        assert len(power_gens) > 0
```

### Acceptance Criteria
- [ ] 8 new tests added to `test_room.py`
- [ ] All tests pass: `uv run pytest app/tests/test_api/test_room.py -v -k "unique"`
- [ ] Unique room logic verified working correctly

---

## Implementation Workflow

### Step 1: DB Init Tests (2-3 hours)
```bash
# Create test structure
mkdir -p backend/app/tests/test_db
touch backend/app/tests/test_db/__init__.py

# Create test file
# Write all 10 tests in test_init_db.py

# Run tests
cd backend
uv run pytest app/tests/test_db/test_init_db.py -v

# Check coverage
uv run pytest app/tests/test_db/test_init_db.py --cov=app.db.init_db --cov-report=term-missing
```

### Step 2: Unique Room Tests (1-2 hours)
```bash
# Add 8 tests to existing test_room.py

# Run tests
uv run pytest app/tests/test_api/test_room.py::TestUniqueRoomLogic -v

# Or run all room tests
uv run pytest app/tests/test_api/test_room.py -v
```

### Step 3: Verification
```bash
# Run all tests
uv run pytest app/tests/ -v

# Full coverage report
uv run pytest --cov=app --cov-report=term-missing --cov-report=html

# Check coverage increased
open htmlcov/index.html
```

---

## Success Metrics

### Test Count
- **Before:** 570 tests
- **After:** 588 tests (+18)

### Coverage
- **Before:** 44.5%
- **After:** 55-60% (estimated)
- **Specific Modules:**
  - `app/db/init_db.py`: 0% â†’ 75%
  - `app/api/v1/endpoints/room.py`: ~70% â†’ 95%

### Quality
- âœ… Database seeding fully verified
- âœ… Unique room logic comprehensively tested
- âœ… All tests passing
- âœ… Clean foundation for future work

---

## Verification Commands

```bash
# Test specific modules
uv run pytest app/tests/test_db/ -v
uv run pytest app/tests/test_api/test_room.py -v

# Coverage for specific modules
uv run pytest --cov=app.db.init_db --cov-report=term-missing
uv run pytest --cov=app.crud.room --cov-report=term-missing

# Full coverage
uv run pytest --cov=app --cov-report=html
```

---

## Definition of Done

- [ ] Directory created: `app/tests/test_db/`
- [ ] 10 DB init tests written and passing
- [ ] 8 unique room tests written and passing
- [ ] Total: 588 tests (570 + 18)
- [ ] Coverage: â‰¥55%
- [ ] All tests green: `uv run pytest app/tests/`
- [ ] ROADMAP.md updated with v2.3.0 quick wins

---

## Out of Scope (Future Versions)

- Middleware testing (security, request_id)
- Datetime deprecation fix (68 instances)
- Incident service testing (session isolation + coverage)
- Game loop testing (complex orchestration)
- DB session management tests

**This ultra-focused plan delivers maximum value in minimum time.**
