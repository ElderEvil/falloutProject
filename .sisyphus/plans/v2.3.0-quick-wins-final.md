# v2.3.0 Quick Wins - Final Implementation Plan

**Status:** Ready for Implementation  
**Created:** 2026-01-23  
**Branch:** `feat/v2.3.0`  
**Scope:** Tier 1 Quick Wins Only  
**Estimated Effort:** 4-6 hours (half day)  
**Target Coverage:** 44.5% â†’ 60-65%

---

## Executive Summary

Focus on **high-value, low-risk wins** to build momentum and establish foundation for future testing efforts.

**Three Tasks:**
1. Datetime deprecation fix (removes warnings)
2. Database initialization tests (critical seeding logic)
3. Unique room verification tests (validates existing feature)

**Deliverables:**
- 24 new tests added (570 â†’ 594)
- 15-20% coverage increase (44.5% â†’ 60-65%)
- Zero Python 3.13+ deprecation warnings
- Clean foundation for Tier 2/3 work

---

## Task 1: Datetime Deprecation Fix â°

**Priority:** HIGH | **Effort:** 30-60 min | **Risk:** LOW

### Scope
Replace all 68 instances of `datetime.utcnow()` with `datetime.now(timezone.utc)`

### Files to Update (21 files total)

#### Model Defaults (5 files)
```python
# BEFORE
from datetime import datetime
created_at: datetime = Field(default_factory=datetime.utcnow)

# AFTER
from datetime import datetime, timezone
created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
```

**Files:**
- `app/models/base.py` - BaseModel timestamps
- `app/models/llm_interaction.py`
- `app/models/chat_message.py`
- `app/models/incident.py`
- `app/models/exploration.py` (update get_utc_now() helper)

#### Service Logic (7 files)
```python
# BEFORE: now = datetime.utcnow()
# AFTER: now = datetime.now(timezone.utc)
```

- `app/services/training_service.py`
- `app/services/death_service.py`
- `app/services/breeding_service.py`
- `app/services/exploration/event_generator.py`
- `app/services/game_loop.py`
- `app/services/relationship_service.py`

#### Model Methods (5 files)
- `app/models/game_state.py`
- `app/models/pregnancy.py`
- `app/models/incident.py`
- `app/models/training.py`
- `app/models/exploration.py`

#### CRUD (2 files)
- `app/crud/exploration.py`
- `app/crud/notification.py`

#### Tests (5 files)
- `app/tests/test_services/test_death_service.py`
- `app/tests/test_services/test_incident_service.py`
- `app/tests/test_services/test_game_loop_exploration.py`
- `app/tests/test_services/test_exploration_service.py`
- `app/tests/test_services/test_breeding_service.py`

### Implementation Steps
1. Add `timezone` to imports: `from datetime import datetime, timezone, timedelta`
2. Replace pattern: `datetime.utcnow()` â†’ `datetime.now(timezone.utc)`
3. For Field defaults: `default_factory=datetime.utcnow` â†’ `default_factory=lambda: datetime.now(timezone.utc)`
4. Run tests after each file: `uv run pytest app/tests/ -x`
5. Verify no warnings: `python -W default::DeprecationWarning -m pytest app/tests/`

### Acceptance Criteria
- [ ] All 68 instances replaced
- [ ] All imports updated with `timezone`
- [ ] All tests pass: `uv run pytest app/tests/`
- [ ] No deprecation warnings when running app/tests
- [ ] Ruff linting passes: `uv run ruff check .`

---

## Task 2: Database Initialization Tests ðŸ’¾

**Priority:** HIGH | **Effort:** 2-3 hours | **Risk:** LOW

### Scope
Test the database seeding logic in `app/db/init_db.py` (currently 0% coverage)

### New Test File
**Create:** `app/tests/test_db/test_init_db.py`

### Test Cases (10 tests)

```python
import pytest
from sqlmodel.ext.asyncio.session import AsyncSession

from app import crud
from app.core.config import settings
from app.db.init_db import init_db

# User Creation Tests (3 tests)
@pytest.mark.asyncio
async def test_init_db_creates_superuser(async_session: AsyncSession):
    """Test init_db creates superuser with correct attributes"""
    await init_db(async_session)
    
    user = await crud.user.get_by_email(
        email=settings.FIRST_SUPERUSER_EMAIL,
        db_session=async_session
    )
    
    assert user is not None
    assert user.is_superuser is True
    assert user.username == settings.FIRST_SUPERUSER_USERNAME
    assert user.email_verified is False  # New users not verified by default

@pytest.mark.asyncio
async def test_init_db_creates_test_user(async_session: AsyncSession):
    """Test init_db creates test user"""
    await init_db(async_session)
    
    user = await crud.user.get_by_email(
        email=settings.EMAIL_TEST_USER,
        db_session=async_session
    )
    
    assert user is not None
    assert user.is_superuser is False
    assert user.username == "TestUser"

@pytest.mark.asyncio
async def test_init_db_skips_existing_users(async_session: AsyncSession):
    """Test init_db doesn't duplicate existing users"""
    # Run init_db twice
    await init_db(async_session)
    await init_db(async_session)
    
    # Should only have 2 users (superuser + test user)
    result = await async_session.execute(select(User))
    users = result.scalars().all()
    assert len(users) == 2

# Vault Seeding Tests (3 tests)
@pytest.mark.asyncio
async def test_init_db_creates_vault_for_test_user(async_session: AsyncSession):
    """Test init_db creates vault for test user only"""
    await init_db(async_session)
    
    test_user = await crud.user.get_by_email(
        email=settings.EMAIL_TEST_USER,
        db_session=async_session
    )
    
    result = await async_session.execute(
        select(Vault).where(Vault.user_id == test_user.id)
    )
    vaults = result.scalars().all()
    
    assert len(vaults) == 1
    assert vaults[0].user_id == test_user.id

@pytest.mark.asyncio
async def test_init_db_creates_rooms_for_vault(async_session: AsyncSession):
    """Test init_db creates 3 rooms for test vault"""
    await init_db(async_session)
    
    test_user = await crud.user.get_by_email(
        email=settings.EMAIL_TEST_USER,
        db_session=async_session
    )
    
    result = await async_session.execute(
        select(Room).join(Vault).where(Vault.user_id == test_user.id)
    )
    rooms = result.scalars().all()
    
    assert len(rooms) == 3

@pytest.mark.asyncio
async def test_init_db_creates_dwellers_for_rooms(async_session: AsyncSession):
    """Test init_db creates 2 dwellers per room (6 total)"""
    await init_db(async_session)
    
    test_user = await crud.user.get_by_email(
        email=settings.EMAIL_TEST_USER,
        db_session=async_session
    )
    
    result = await async_session.execute(
        select(Dweller).join(Vault).where(Vault.user_id == test_user.id)
    )
    dwellers = result.scalars().all()
    
    assert len(dwellers) == 6  # 3 rooms Ã— 2 dwellers

# Equipment Seeding Tests (2 tests)
@pytest.mark.asyncio
async def test_init_db_creates_outfits_for_dwellers(async_session: AsyncSession):
    """Test init_db creates 1 outfit per dweller"""
    await init_db(async_session)
    
    test_user = await crud.user.get_by_email(
        email=settings.EMAIL_TEST_USER,
        db_session=async_session
    )
    
    result = await async_session.execute(
        select(Outfit).join(Dweller).join(Vault).where(Vault.user_id == test_user.id)
    )
    outfits = result.scalars().all()
    
    assert len(outfits) == 6

@pytest.mark.asyncio
async def test_init_db_creates_weapons_for_dwellers(async_session: AsyncSession):
    """Test init_db creates 1 weapon per dweller"""
    await init_db(async_session)
    
    test_user = await crud.user.get_by_email(
        email=settings.EMAIL_TEST_USER,
        db_session=async_session
    )
    
    result = await async_session.execute(
        select(Weapon).join(Dweller).join(Vault).where(Vault.user_id == test_user.id)
    )
    weapons = result.scalars().all()
    
    assert len(weapons) == 6

# Integration Test (2 tests)
@pytest.mark.asyncio
async def test_init_db_complete_seeding(async_session: AsyncSession):
    """Test init_db creates complete game state for test user"""
    await init_db(async_session)
    
    test_user = await crud.user.get_by_email(
        email=settings.EMAIL_TEST_USER,
        db_session=async_session
    )
    
    # Verify complete hierarchy
    vault = (await async_session.execute(
        select(Vault).where(Vault.user_id == test_user.id)
    )).scalar_one()
    
    rooms = (await async_session.execute(
        select(Room).where(Room.vault_id == vault.id)
    )).scalars().all()
    
    for room in rooms:
        dwellers = (await async_session.execute(
            select(Dweller).where(Dweller.room_id == room.id)
        )).scalars().all()
        
        assert len(dwellers) == 2
        
        for dweller in dwellers:
            # Check outfit exists
            outfit = (await async_session.execute(
                select(Outfit).where(Outfit.dweller_id == dweller.id)
            )).scalar_one_or_none()
            assert outfit is not None
            
            # Check weapon exists
            weapon = (await async_session.execute(
                select(Weapon).where(Weapon.dweller_id == dweller.id)
            )).scalar_one_or_none()
            assert weapon is not None

@pytest.mark.asyncio
async def test_init_db_superuser_has_no_vault(async_session: AsyncSession):
    """Test init_db doesn't create vault for superuser"""
    await init_db(async_session)
    
    superuser = await crud.user.get_by_email(
        email=settings.FIRST_SUPERUSER_EMAIL,
        db_session=async_session
    )
    
    result = await async_session.execute(
        select(Vault).where(Vault.user_id == superuser.id)
    )
    vaults = result.scalars().all()
    
    assert len(vaults) == 0
```

### Additional Setup
**Create:** `app/tests/test_db/__init__.py` (empty file)
**Create:** `app/tests/test_db/conftest.py` (if needed for fixtures)

### Acceptance Criteria
- [ ] Test directory created: `app/tests/test_db/`
- [ ] 10 tests written in `test_init_db.py`
- [ ] All tests pass: `uv run pytest app/tests/test_db/test_init_db.py -v`
- [ ] Coverage check: `uv run pytest --cov=app.db.init_db --cov-report=term-missing`
- [ ] Target: â‰¥75% coverage for init_db.py

---

## Task 3: Unique Room Verification Tests ðŸ 

**Priority:** MEDIUM | **Effort:** 1-2 hours | **Risk:** LOW

### Scope
Add comprehensive tests for unique room filtering logic (already implemented, needs verification)

### Existing File
**Expand:** `app/tests/test_api/test_room.py`

### New Test Cases (8 tests)

```python
import pytest
from httpx import AsyncClient
from sqlmodel.ext.asyncio.session import AsyncSession

from app.models.room import Room
from app.models.vault import Vault
from app.utils.exceptions import UniqueRoomViolationException

# Uniqueness Property Tests (2 tests)
@pytest.mark.asyncio
async def test_room_is_unique_true_when_no_incremental_cost():
    """Test is_unique property returns True when incremental_cost is None"""
    room = Room(
        name="Vault Door",
        vault_id=uuid4(),
        level=1,
        incremental_cost=None  # Unique rooms have no incremental cost
    )
    assert room.is_unique is True

@pytest.mark.asyncio
async def test_room_is_unique_false_when_has_incremental_cost():
    """Test is_unique property returns False when incremental_cost exists"""
    room = Room(
        name="Power Generator",
        vault_id=uuid4(),
        level=1,
        incremental_cost={"caps": 500, "power": 10}
    )
    assert room.is_unique is False

# Build Validation Tests (3 tests)
@pytest.mark.asyncio
async def test_build_unique_room_fails_when_already_exists(
    async_client: AsyncClient,
    superuser_token_headers: dict,
    async_session: AsyncSession,
):
    """Test building duplicate unique room raises error"""
    # Create vault
    vault = await crud.vault.create(async_session, obj_in=VaultCreate(...))
    await async_session.commit()
    
    # Build first Vault Door (unique room)
    room_data = {
        "name": "Vault Door",
        "vault_id": str(vault.id),
        "level": 1
    }
    
    response1 = await async_client.post(
        "/api/v1/rooms/build/",
        json=room_data,
        headers=superuser_token_headers
    )
    assert response1.status_code == 201
    
    # Attempt to build second Vault Door
    response2 = await async_client.post(
        "/api/v1/rooms/build/",
        json=room_data,
        headers=superuser_token_headers
    )
    assert response2.status_code == 400
    assert "unique room" in response2.json()["detail"].lower()

@pytest.mark.asyncio
async def test_build_non_unique_room_allows_multiple(
    async_client: AsyncClient,
    superuser_token_headers: dict,
    async_session: AsyncSession,
):
    """Test building multiple non-unique rooms succeeds"""
    vault = await crud.vault.create(async_session, obj_in=VaultCreate(...))
    await async_session.commit()
    
    # Build first Power Generator (non-unique)
    room_data = {
        "name": "Power Generator",
        "vault_id": str(vault.id),
        "level": 1
    }
    
    response1 = await async_client.post(
        "/api/v1/rooms/build/",
        json=room_data,
        headers=superuser_token_headers
    )
    assert response1.status_code == 201
    
    # Build second Power Generator (should succeed)
    response2 = await async_client.post(
        "/api/v1/rooms/build/",
        json=room_data,
        headers=superuser_token_headers
    )
    assert response2.status_code == 201

@pytest.mark.asyncio
async def test_build_unique_room_succeeds_when_first(
    async_client: AsyncClient,
    superuser_token_headers: dict,
    async_session: AsyncSession,
):
    """Test building unique room succeeds when it's the first"""
    vault = await crud.vault.create(async_session, obj_in=VaultCreate(...))
    await async_session.commit()
    
    room_data = {
        "name": "Vault Door",
        "vault_id": str(vault.id),
        "level": 1
    }
    
    response = await async_client.post(
        "/api/v1/rooms/build/",
        json=room_data,
        headers=superuser_token_headers
    )
    
    assert response.status_code == 201
    data = response.json()
    assert data["name"] == "Vault Door"
    assert data["level"] == 1

# Buildable Rooms Filtering Tests (3 tests)
@pytest.mark.asyncio
async def test_buildable_rooms_excludes_built_unique_rooms(
    async_client: AsyncClient,
    superuser_token_headers: dict,
    async_session: AsyncSession,
):
    """Test buildable rooms endpoint excludes already-built unique rooms"""
    vault = await crud.vault.create(async_session, obj_in=VaultCreate(...))
    
    # Build Vault Door
    await crud.room.build(
        async_session,
        vault_id=vault.id,
        room_name="Vault Door",
        level=1
    )
    await async_session.commit()
    
    # Get buildable rooms
    response = await async_client.get(
        f"/api/v1/rooms/buildable/{vault.id}/",
        headers=superuser_token_headers
    )
    
    assert response.status_code == 200
    buildable_rooms = response.json()
    
    # Vault Door should not be in buildable list
    vault_doors = [r for r in buildable_rooms if r["name"].lower() == "vault door"]
    assert len(vault_doors) == 0

@pytest.mark.asyncio
async def test_buildable_rooms_includes_unbuilt_unique_rooms(
    async_client: AsyncClient,
    superuser_token_headers: dict,
    async_session: AsyncSession,
):
    """Test buildable rooms includes unique rooms that haven't been built"""
    vault = await crud.vault.create(async_session, obj_in=VaultCreate(...))
    await async_session.commit()
    
    response = await async_client.get(
        f"/api/v1/rooms/buildable/{vault.id}/",
        headers=superuser_token_headers
    )
    
    assert response.status_code == 200
    buildable_rooms = response.json()
    
    # Vault Door should be in buildable list (not built yet)
    vault_doors = [r for r in buildable_rooms if r["name"].lower() == "vault door"]
    assert len(vault_doors) > 0

@pytest.mark.asyncio
async def test_buildable_rooms_always_includes_non_unique_rooms(
    async_client: AsyncClient,
    superuser_token_headers: dict,
    async_session: AsyncSession,
):
    """Test buildable rooms always includes non-unique rooms even if built"""
    vault = await crud.vault.create(async_session, obj_in=VaultCreate(...))
    
    # Build Power Generator
    await crud.room.build(
        async_session,
        vault_id=vault.id,
        room_name="Power Generator",
        level=1
    )
    await async_session.commit()
    
    response = await async_client.get(
        f"/api/v1/rooms/buildable/{vault.id}/",
        headers=superuser_token_headers
    )
    
    assert response.status_code == 200
    buildable_rooms = response.json()
    
    # Power Generator should still be buildable (non-unique)
    power_gens = [r for r in buildable_rooms if r["name"].lower() == "power generator"]
    assert len(power_gens) > 0
```

### Acceptance Criteria
- [ ] 8 new tests added to `test_room.py`
- [ ] All tests pass: `uv run pytest app/tests/test_api/test_room.py::test_room_is_unique* -v`
- [ ] All tests pass: `uv run pytest app/tests/test_api/test_room.py::test_build* -v`
- [ ] All tests pass: `uv run pytest app/tests/test_api/test_room.py::test_buildable* -v`
- [ ] Unique room logic verified working correctly

---

## Implementation Order

### Step 1: Datetime Fix (Morning - 1 hour)
1. Update model defaults (5 files)
2. Update services (7 files)
3. Update model methods (5 files)
4. Update CRUD (2 files)
5. Update tests (5 files)
6. Run full test suite
7. Verify no warnings

### Step 2: DB Init Tests (Morning/Afternoon - 2-3 hours)
1. Create test directory structure
2. Write user creation tests (3 tests)
3. Write vault seeding tests (3 tests)
4. Write equipment tests (2 tests)
5. Write integration tests (2 tests)
6. Run tests: `uv run pytest app/tests/test_db/ -v`
7. Check coverage

### Step 3: Unique Room Tests (Afternoon - 1-2 hours)
1. Write property tests (2 tests)
2. Write build validation tests (3 tests)
3. Write buildable filtering tests (3 tests)
4. Run tests: `uv run pytest app/tests/test_api/test_room.py -v`
5. Verify all assertions pass

---

## Success Metrics

### Test Count
- **Before:** 570 tests
- **After:** 594 tests (+24)

### Coverage
- **Before:** 44.5%
- **After:** 60-65% (target)
- **Gain:** ~15-20 percentage points

### Quality
- âœ… Zero datetime deprecation warnings
- âœ… Database seeding fully tested
- âœ… Unique room logic verified
- âœ… All tests passing
- âœ… Ruff linting clean

---

## Verification Commands

```bash
# Full test suite
uv run pytest app/tests/ -v

# Coverage report
uv run pytest --cov=app --cov-report=term-missing --cov-report=html

# Specific modules
uv run pytest --cov=app.db.init_db --cov-report=term-missing
uv run pytest app/tests/test_api/test_room.py -v

# Check for deprecation warnings
python -W default::DeprecationWarning -m pytest app/tests/

# Linting
uv run ruff check .
uv run ruff format .
```

---

## Definition of Done

- [ ] All 68 datetime.utcnow() replaced
- [ ] 10 DB init tests written and passing
- [ ] 8 unique room tests written and passing
- [ ] Total test count: 594+ (570 + 24)
- [ ] Coverage: â‰¥60%
- [ ] No deprecation warnings
- [ ] Ruff linting passes
- [ ] All tests green: `uv run pytest app/tests/`
- [ ] ROADMAP.md updated (mark quick wins complete)

---

## Next Steps (After Quick Wins)

**Reassess with user:**
- Continue to Tier 2 (DB session + incident service)?
- Move to Tier 3 (game loop)?
- Different priority?
- Ship v2.3.0 with quick wins only?

**This plan is COMPLETE and ready for implementation.**
