# v2.3.0 Quick Wins + Enhanced Fixtures - FINAL Plan

**Status:** Ready for Implementation
**Created:** 2026-01-23
**Branch:** `feat/v2.3.0`
**Scope:** DB Init Tests + Unique Room Tests + Reusable Fixtures
**Estimated Effort:** 4-5 hours
**Target Coverage:** 44.5% â†’ 55-60%

---

## Scope: 3 High-Value Tasks

### âœ… IN SCOPE
1. **Enhanced Test Fixtures** - Composite fixtures for common scenarios (1 hour)
2. **Database Initialization Tests** - 10 tests (2-3 hours)
3. **Unique Room Verification Tests** - 8 tests (1-2 hours)

**Total:** 18 new tests + reusable fixtures, 4-5 hours work

---

## Task 1: Enhanced Test Fixtures ðŸŽ¯

**Priority:** HIGH (do first - enables other tests) | **Effort:** 1 hour

### Why This Matters
- **Current fixtures:** Basic entities (vault, dweller, room) - must compose manually
- **New fixtures:** Pre-composed scenarios (vault_with_rooms, room_with_dwellers)
- **Benefit:** Write tests faster, more readable, less boilerplate

### Existing Fixtures (already good!)
```python
# From conftest.py and test_api/conftest.py
- async_session - Database session
- vault - Empty vault
- dweller - Single dweller
- room - Single room
- dweller_with_room - Dweller assigned to room
```

### New Composite Fixtures to Add

**File:** `backend/app/tests/conftest.py` (add to end of file)

```python
# ============================================================================
# COMPOSITE FIXTURES - Common test scenarios
# ============================================================================

@pytest_asyncio.fixture(name="vault_with_rooms")
async def vault_with_rooms_fixture(
    async_session: AsyncSession,
    vault: "Vault"
) -> tuple["Vault", list["Room"]]:
    """
    Create a vault with 3 rooms of different types.

    Returns:
        Tuple of (vault, [room1, room2, room3])

    Usage:
        async def test_something(vault_with_rooms):
            vault, rooms = vault_with_rooms
            assert len(rooms) == 3
    """
    from app.schemas.room import RoomCreate

    room_configs = [
        {"name": "Power Generator", "level": 1, "tier": 1},
        {"name": "Water Treatment", "level": 1, "tier": 1},
        {"name": "Diner", "level": 1, "tier": 1},
    ]

    rooms = []
    for config in room_configs:
        room_in = RoomCreate(**config, vault_id=vault.id)
        room = await crud.room.create(db_session=async_session, obj_in=room_in)
        rooms.append(room)

    await async_session.commit()
    return vault, rooms


@pytest_asyncio.fixture(name="room_with_dwellers")
async def room_with_dwellers_fixture(
    async_session: AsyncSession,
    room: "Room",
) -> tuple["Room", list["Dweller"]]:
    """
    Create a room with 2 dwellers assigned.

    Returns:
        Tuple of (room, [dweller1, dweller2])

    Usage:
        async def test_room_capacity(room_with_dwellers):
            room, dwellers = room_with_dwellers
            assert len(dwellers) == 2
    """
    from app.schemas.dweller import DwellerCreate
    from app.tests.factory.dwellers import create_random_common_dweller

    dwellers = []
    for _ in range(2):
        dweller_data = create_random_common_dweller()
        dweller_in = DwellerCreate(
            **dweller_data,
            vault_id=room.vault_id,
            room_id=room.id
        )
        dweller = await crud.dweller.create(db_session=async_session, obj_in=dweller_in)
        dwellers.append(dweller)

    await async_session.commit()
    return room, dwellers


@pytest_asyncio.fixture(name="equipped_dweller")
async def equipped_dweller_fixture(
    async_session: AsyncSession,
    dweller: "Dweller",
) -> tuple["Dweller", "Outfit", "Weapon"]:
    """
    Create a dweller with outfit and weapon equipped.

    Returns:
        Tuple of (dweller, outfit, weapon)

    Usage:
        async def test_combat_power(equipped_dweller):
            dweller, outfit, weapon = equipped_dweller
            assert dweller.calculate_combat_power() > 0
    """
    from app.tests.factory.items import create_fake_outfit, create_fake_weapon

    # Create outfit
    outfit_data = create_fake_outfit()
    outfit_data["dweller_id"] = dweller.id
    outfit = await crud.outfit.create(db_session=async_session, obj_in=outfit_data)

    # Create weapon
    weapon_data = create_fake_weapon()
    weapon_data["dweller_id"] = dweller.id
    weapon = await crud.weapon.create(db_session=async_session, obj_in=weapon_data)

    await async_session.commit()
    return dweller, outfit, weapon


@pytest_asyncio.fixture(name="populated_vault")
async def populated_vault_fixture(
    async_session: AsyncSession,
) -> tuple["Vault", list["Room"], list["Dweller"]]:
    """
    Create a fully populated vault: 3 rooms, each with 2 dwellers (6 total).

    Returns:
        Tuple of (vault, rooms, dwellers)

    Usage:
        async def test_game_loop(populated_vault):
            vault, rooms, dwellers = populated_vault
            assert len(rooms) == 3
            assert len(dwellers) == 6
    """
    from faker import Faker
    from app.schemas.user import UserCreate
    from app.schemas.vault import VaultCreateWithUserID
    from app.schemas.room import RoomCreate
    from app.schemas.dweller import DwellerCreate
    from app.tests.factory.dwellers import create_random_common_dweller

    fake = Faker()

    # Create user
    user_in = UserCreate(
        username=fake.user_name(),
        email=fake.email(),
        password=fake.password()
    )
    user = await crud.user.create(db_session=async_session, obj_in=user_in)

    # Create vault
    vault_in = VaultCreateWithUserID(
        number=random.randint(1, 999),
        bottle_caps=1000,
        user_id=user.id
    )
    vault = await crud.vault.create(db_session=async_session, obj_in=vault_in)

    # Create 3 rooms
    room_configs = [
        {"name": "Power Generator", "level": 1},
        {"name": "Water Treatment", "level": 1},
        {"name": "Diner", "level": 1},
    ]

    rooms = []
    dwellers = []

    for config in room_configs:
        room_in = RoomCreate(**config, vault_id=vault.id)
        room = await crud.room.create(db_session=async_session, obj_in=room_in)
        rooms.append(room)

        # Create 2 dwellers per room
        for _ in range(2):
            dweller_data = create_random_common_dweller()
            dweller_in = DwellerCreate(
                **dweller_data,
                vault_id=vault.id,
                room_id=room.id
            )
            dweller = await crud.dweller.create(db_session=async_session, obj_in=dweller_in)
            dwellers.append(dweller)

    await async_session.commit()
    return vault, rooms, dwellers


@pytest_asyncio.fixture(name="vault_with_resources")
async def vault_with_resources_fixture(
    async_session: AsyncSession,
    vault: "Vault",
) -> "Vault":
    """
    Create a vault with abundant resources for testing economy/building.

    Returns:
        Vault with 10000 caps, 100 power/food/water

    Usage:
        async def test_expensive_build(vault_with_resources):
            # Can afford anything
            assert vault_with_resources.bottle_caps == 10000
    """
    vault.bottle_caps = 10000
    vault.power = 100
    vault.food = 100
    vault.water = 100
    async_session.add(vault)
    await async_session.commit()
    await async_session.refresh(vault)
    return vault
```

### Benefits of New Fixtures

| Fixture | Use Case | Saves |
|---------|----------|-------|
| `vault_with_rooms` | Test room operations, resource management | 10+ lines per test |
| `room_with_dwellers` | Test dweller assignment, room capacity | 15+ lines per test |
| `equipped_dweller` | Test combat, equipment bonuses | 12+ lines per test |
| `populated_vault` | Test game loop, incidents, exploration | 30+ lines per test |
| `vault_with_resources` | Test building, upgrades, purchases | 5+ lines per test |

### Acceptance Criteria
- [ ] 5 new composite fixtures added to `conftest.py`
- [ ] All fixtures documented with docstrings
- [ ] Quick test to verify they work: `uv run pytest --fixtures | grep -A 3 "vault_with_rooms"`

---

## Task 2: Database Initialization Tests ðŸ’¾

**Priority:** HIGH | **Effort:** 2-3 hours | **Coverage:** 0% â†’ 75%

### What We're Testing
Database seeding logic in `app/db/init_db.py`

### Test File
**Create:** `backend/app/tests/test_db/test_init_db.py`

### Test Cases (10 tests)

**Benefits of our new fixtures:** Can use `populated_vault` pattern as reference!

```python
import pytest
from sqlmodel import select
from sqlmodel.ext.asyncio.session import AsyncSession

from app import crud
from app.core.config import settings
from app.db.init_db import init_db
from app.models.user import User
from app.models.vault import Vault
from app.models.room import Room
from app.models.dweller import Dweller
from app.models.outfit import Outfit
from app.models.weapon import Weapon


class TestInitDB:
    """Test database initialization seeding."""

    @pytest.mark.asyncio
    async def test_creates_superuser(self, async_session: AsyncSession):
        """Verify superuser created with correct attributes."""
        await init_db(async_session)

        user = await crud.user.get_by_email(
            email=settings.FIRST_SUPERUSER_EMAIL,
            db_session=async_session
        )

        assert user is not None
        assert user.is_superuser is True
        assert user.username == settings.FIRST_SUPERUSER_USERNAME

    @pytest.mark.asyncio
    async def test_creates_test_user(self, async_session: AsyncSession):
        """Verify test user created."""
        await init_db(async_session)

        user = await crud.user.get_by_email(
            email=settings.EMAIL_TEST_USER,
            db_session=async_session
        )

        assert user is not None
        assert user.is_superuser is False
        assert user.username == "TestUser"

    @pytest.mark.asyncio
    async def test_idempotent_multiple_runs(self, async_session: AsyncSession):
        """Verify init_db doesn't duplicate users on multiple runs."""
        await init_db(async_session)
        await init_db(async_session)

        result = await async_session.execute(select(User))
        users = result.scalars().all()
        assert len(users) == 2  # Only superuser + test user

    @pytest.mark.asyncio
    async def test_creates_vault_for_test_user_only(self, async_session: AsyncSession):
        """Verify vault created for test user, not superuser."""
        await init_db(async_session)

        test_user = await crud.user.get_by_email(
            email=settings.EMAIL_TEST_USER,
            db_session=async_session
        )
        superuser = await crud.user.get_by_email(
            email=settings.FIRST_SUPERUSER_EMAIL,
            db_session=async_session
        )

        # Test user has vault
        test_vaults = await async_session.execute(
            select(Vault).where(Vault.user_id == test_user.id)
        )
        assert len(test_vaults.scalars().all()) == 1

        # Superuser has no vault
        super_vaults = await async_session.execute(
            select(Vault).where(Vault.user_id == superuser.id)
        )
        assert len(super_vaults.scalars().all()) == 0

    @pytest.mark.asyncio
    async def test_creates_three_rooms(self, async_session: AsyncSession):
        """Verify 3 rooms created."""
        await init_db(async_session)

        test_user = await crud.user.get_by_email(
            email=settings.EMAIL_TEST_USER,
            db_session=async_session
        )

        rooms = await async_session.execute(
            select(Room).join(Vault).where(Vault.user_id == test_user.id)
        )
        assert len(rooms.scalars().all()) == 3

    @pytest.mark.asyncio
    async def test_creates_six_dwellers(self, async_session: AsyncSession):
        """Verify 6 dwellers created (2 per room)."""
        await init_db(async_session)

        test_user = await crud.user.get_by_email(
            email=settings.EMAIL_TEST_USER,
            db_session=async_session
        )

        dwellers = await async_session.execute(
            select(Dweller).join(Vault).where(Vault.user_id == test_user.id)
        )
        assert len(dwellers.scalars().all()) == 6

    @pytest.mark.asyncio
    async def test_all_dwellers_have_outfits(self, async_session: AsyncSession):
        """Verify each dweller has outfit."""
        await init_db(async_session)

        test_user = await crud.user.get_by_email(
            email=settings.EMAIL_TEST_USER,
            db_session=async_session
        )

        outfits = await async_session.execute(
            select(Outfit).join(Dweller).join(Vault).where(Vault.user_id == test_user.id)
        )
        assert len(outfits.scalars().all()) == 6

    @pytest.mark.asyncio
    async def test_all_dwellers_have_weapons(self, async_session: AsyncSession):
        """Verify each dweller has weapon."""
        await init_db(async_session)

        test_user = await crud.user.get_by_email(
            email=settings.EMAIL_TEST_USER,
            db_session=async_session
        )

        weapons = await async_session.execute(
            select(Weapon).join(Dweller).join(Vault).where(Vault.user_id == test_user.id)
        )
        assert len(weapons.scalars().all()) == 6

    @pytest.mark.asyncio
    async def test_complete_hierarchy(self, async_session: AsyncSession):
        """Verify complete entity hierarchy."""
        await init_db(async_session)

        test_user = await crud.user.get_by_email(
            email=settings.EMAIL_TEST_USER,
            db_session=async_session
        )

        vault_result = await async_session.execute(
            select(Vault).where(Vault.user_id == test_user.id)
        )
        vault = vault_result.scalar_one()

        rooms_result = await async_session.execute(
            select(Room).where(Room.vault_id == vault.id)
        )
        rooms = rooms_result.scalars().all()
        assert len(rooms) == 3

        # Each room has 2 dwellers with equipment
        for room in rooms:
            dwellers_result = await async_session.execute(
                select(Dweller).where(Dweller.room_id == room.id)
            )
            dwellers = dwellers_result.scalars().all()
            assert len(dwellers) == 2

            for dweller in dwellers:
                # Has outfit
                outfit_result = await async_session.execute(
                    select(Outfit).where(Outfit.dweller_id == dweller.id)
                )
                assert outfit_result.scalar_one_or_none() is not None

                # Has weapon
                weapon_result = await async_session.execute(
                    select(Weapon).where(Weapon.dweller_id == dweller.id)
                )
                assert weapon_result.scalar_one_or_none() is not None

    @pytest.mark.asyncio
    async def test_dwellers_properly_assigned_to_rooms(self, async_session: AsyncSession):
        """Verify dweller-room relationships correct."""
        await init_db(async_session)

        test_user = await crud.user.get_by_email(
            email=settings.EMAIL_TEST_USER,
            db_session=async_session
        )

        rooms_result = await async_session.execute(
            select(Room).join(Vault).where(Vault.user_id == test_user.id)
        )
        rooms = rooms_result.scalars().all()

        for room in rooms:
            dwellers_result = await async_session.execute(
                select(Dweller).where(Dweller.room_id == room.id)
            )
            dwellers = dwellers_result.scalars().all()

            assert len(dwellers) == 2
            for dweller in dwellers:
                assert dweller.room_id == room.id
                assert dweller.vault_id == room.vault_id
```

### Setup
```bash
mkdir -p backend/app/tests/test_db
touch backend/app/tests/test_db/__init__.py
```

### Acceptance Criteria
- [ ] 10 tests written and passing
- [ ] Coverage â‰¥75% for `app/db/init_db.py`

---

## Task 3: Unique Room Tests ðŸ 

**Priority:** MEDIUM | **Effort:** 1-2 hours

### Test File
**Expand:** `backend/app/tests/test_api/test_room.py`

**Benefits of fixtures:** Can use `vault_with_resources` for building tests!

### Test Cases (8 tests)

```python
class TestUniqueRoomLogic:
    """Test unique room filtering and validation."""

    @pytest.mark.asyncio
    async def test_is_unique_property_true_when_no_incremental_cost(self):
        """Room with no incremental_cost is unique."""
        room = Room(
            name="Vault Door",
            vault_id=uuid4(),
            level=1,
            incremental_cost=None
        )
        assert room.is_unique is True

    @pytest.mark.asyncio
    async def test_is_unique_property_false_when_has_incremental_cost(self):
        """Room with incremental_cost is non-unique."""
        room = Room(
            name="Power Generator",
            vault_id=uuid4(),
            level=1,
            incremental_cost={"caps": 500}
        )
        assert room.is_unique is False

    @pytest.mark.asyncio
    async def test_cannot_build_duplicate_unique_room(
        self,
        async_client: AsyncClient,
        superuser_token_headers: dict,
        vault_with_resources: "Vault",
    ):
        """Building duplicate unique room fails."""
        room_data = {
            "name": "Vault Door",
            "vault_id": str(vault_with_resources.id),
            "level": 1
        }

        # First build succeeds
        response1 = await async_client.post(
            "/api/v1/rooms/build/",
            json=room_data,
            headers=superuser_token_headers
        )
        assert response1.status_code == 201

        # Second build fails
        response2 = await async_client.post(
            "/api/v1/rooms/build/",
            json=room_data,
            headers=superuser_token_headers
        )
        assert response2.status_code == 400
        assert "unique" in response2.json()["detail"].lower()

    @pytest.mark.asyncio
    async def test_can_build_multiple_non_unique_rooms(
        self,
        async_client: AsyncClient,
        superuser_token_headers: dict,
        vault_with_resources: "Vault",
    ):
        """Building multiple non-unique rooms succeeds."""
        room_data = {
            "name": "Power Generator",
            "vault_id": str(vault_with_resources.id),
            "level": 1
        }

        # First build
        response1 = await async_client.post(
            "/api/v1/rooms/build/",
            json=room_data,
            headers=superuser_token_headers
        )
        assert response1.status_code == 201

        # Second build also succeeds
        response2 = await async_client.post(
            "/api/v1/rooms/build/",
            json=room_data,
            headers=superuser_token_headers
        )
        assert response2.status_code == 201

    @pytest.mark.asyncio
    async def test_first_unique_room_builds_successfully(
        self,
        async_client: AsyncClient,
        superuser_token_headers: dict,
        vault_with_resources: "Vault",
    ):
        """First unique room builds without issues."""
        room_data = {
            "name": "Vault Door",
            "vault_id": str(vault_with_resources.id),
            "level": 1
        }

        response = await async_client.post(
            "/api/v1/rooms/build/",
            json=room_data,
            headers=superuser_token_headers
        )

        assert response.status_code == 201
        assert response.json()["name"] == "Vault Door"

    @pytest.mark.asyncio
    async def test_buildable_excludes_built_unique_rooms(
        self,
        async_client: AsyncClient,
        superuser_token_headers: dict,
        vault_with_rooms: tuple["Vault", list["Room"]],
        async_session: AsyncSession,
    ):
        """Built unique rooms excluded from buildable list."""
        vault, rooms = vault_with_rooms

        # Build Vault Door
        await crud.room.build(
            async_session,
            vault_id=vault.id,
            room_name="Vault Door",
            level=1
        )
        await async_session.commit()

        response = await async_client.get(
            f"/api/v1/rooms/buildable/{vault.id}/",
            headers=superuser_token_headers
        )

        assert response.status_code == 200
        buildable = response.json()
        vault_doors = [r for r in buildable if r["name"] == "Vault Door"]
        assert len(vault_doors) == 0

    @pytest.mark.asyncio
    async def test_buildable_includes_unbuilt_unique_rooms(
        self,
        async_client: AsyncClient,
        superuser_token_headers: dict,
        vault: "Vault",
    ):
        """Unbuilt unique rooms included in buildable list."""
        response = await async_client.get(
            f"/api/v1/rooms/buildable/{vault.id}/",
            headers=superuser_token_headers
        )

        assert response.status_code == 200
        buildable = response.json()
        vault_doors = [r for r in buildable if r["name"] == "Vault Door"]
        assert len(vault_doors) > 0

    @pytest.mark.asyncio
    async def test_buildable_always_includes_non_unique_rooms(
        self,
        async_client: AsyncClient,
        superuser_token_headers: dict,
        vault_with_rooms: tuple["Vault", list["Room"]],
        async_session: AsyncSession,
    ):
        """Non-unique rooms always buildable even if built."""
        vault, rooms = vault_with_rooms

        # Build Power Generator
        await crud.room.build(
            async_session,
            vault_id=vault.id,
            room_name="Power Generator",
            level=1
        )
        await async_session.commit()

        response = await async_client.get(
            f"/api/v1/rooms/buildable/{vault.id}/",
            headers=superuser_token_headers
        )

        assert response.status_code == 200
        buildable = response.json()
        power_gens = [r for r in buildable if r["name"] == "Power Generator"]
        assert len(power_gens) > 0
```

### Acceptance Criteria
- [ ] 8 new tests added
- [ ] Uses new fixtures (`vault_with_resources`, `vault_with_rooms`)
- [ ] All tests pass

---

## Implementation Order

### Step 1: Enhanced Fixtures (1 hour)
```bash
# Edit backend/app/tests/conftest.py
# Add 5 composite fixtures at end of file

# Verify fixtures work
uv run pytest --fixtures | grep "vault_with"
```

### Step 2: DB Init Tests (2-3 hours)
```bash
mkdir -p backend/app/tests/test_db
touch backend/app/tests/test_db/__init__.py

# Write tests using patterns from populated_vault fixture

uv run pytest app/tests/test_db/test_init_db.py -v
```

### Step 3: Unique Room Tests (1-2 hours)
```bash
# Expand test_room.py
# Use vault_with_resources fixture

uv run pytest app/tests/test_api/test_room.py::TestUniqueRoomLogic -v
```

---

## Success Metrics

### Test Infrastructure
- **Fixtures:** 5 new composite fixtures (huge productivity boost)
- **Tests:** 18 new tests (570 â†’ 588)
- **Coverage:** 44.5% â†’ 55-60%

### Future Benefits
- Faster test writing (50% less boilerplate)
- More readable tests
- Consistent test data patterns
- Easy to add incident/game loop tests later

---

## Definition of Done

- [ ] 5 composite fixtures added to `conftest.py`
- [ ] 10 DB init tests passing
- [ ] 8 unique room tests passing
- [ ] Total: 588 tests
- [ ] Coverage: â‰¥55%
- [ ] All fixtures documented
- [ ] ROADMAP.md updated

---

**This plan delivers maximum long-term value with reusable test infrastructure.**
